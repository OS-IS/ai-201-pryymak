### Тестування для підробки міжсайтових запитів

**Резюме**  
Cross-Site Request Forgery (CSRF) — це атака, яка змушує кінцевого користувача виконувати непередбачені дії на веб-застосунку, в якому він зараз аутентифікований. За допомогою трохи соціальної інженерії (наприклад, відправлення посилання через електронну пошту або чат) зловмисник може змусити користувачів веб-застосунку виконувати дії, які вибрав він сам. Успішна експлуатація CSRF може скомпрометувати дані користувача та операції, коли атака націлена на звичайного користувача. Якщо кінцевим користувачем є обліковий запис адміністратора, атака CSRF може скомпрометувати весь веб-застосунок.

CSRF залежить від:

1. Поведінки веб-браузера щодо обробки інформації, пов'язаної з сесією, такої як куки та HTTP-автентифікація.
2. Знання зловмисником дійсних URL-адрес веб-застосунку, запитів або функціональності.
3. Управління сесією застосунку, яке покладається тільки на інформацію, відому браузеру.
4. Наявності HTML-тегів, присутність яких викликає негайний доступ до HTTP[S] ресурсу; наприклад, тег зображення img.

Пункти 1, 2 і 3 є необхідними для наявності вразливості, тоді як пункт 4 полегшує фактичну експлуатацію, але не є суворо необхідним.

Браузери автоматично відправляють інформацію, яка використовується для ідентифікації сесії користувача. Припустимо, сайт є сайтом, що хостить веб-застосунок, і користувач-жертва щойно аутентифікувався на сайті. У відповідь сайт відправляє жертві куки, що ідентифікують запити, надіслані жертвою, як частину її аутентифікованої сесії. Як тільки браузер отримує куки, встановлені сайтом, він автоматично відправляє їх разом з будь-якими подальшими запитами, спрямованими на сайт.  
Якщо застосунок не використовує інформацію, пов'язану з сесією, в URL-адресах, то URL-адреси застосунку, їхні параметри та дійсні значення можуть бути ідентифіковані. Це може бути здійснено через аналіз коду або доступ до застосунку та запис форм і URL-адрес, вбудованих у HTML або JavaScript.  
"Відомо браузеру" стосується такої інформації, як куки або HTTP-автентифікація (наприклад, Basic Authentication, а не автентифікація на основі форм), яка зберігається в браузері і після цього присутня на кожному запиті, спрямованому до області застосунку, яка вимагає такої автентифікації. Наступні обговорення вразливостей стосуються застосунків, які повністю покладаються на такого роду інформацію для ідентифікації сесії користувача.

Для спрощення розглянемо URL-адреси, доступні через GET (хоча обговорення стосується також POST-запитів). Якщо жертва вже аутентифікована, подання ще одного запиту автоматично відправить куки разом з ним. На малюнку нижче показано, як користувач отримує доступ до застосунку на www.example.com.

![](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/images/Session_riding.GIF)

Рисунок 4.6.5-1: Session Riding

Запит GET може бути надісланий користувачем кількома різними способами:

Використовуючи веб-застосунок
Вводячи URL безпосередньо в браузері
Перебуваючи за зовнішнім посиланням, яке вказує на цей URL
Ці виклики для застосунку непомітні. Зокрема, третій спосіб може бути досить небезпечним. Існує низка технік і вразливостей, які можуть приховати реальні властивості посилання. Посилання може бути вбудоване в електронну пошту, з'являтися на шкідливому сайті, на який користувача заманюють, або бути частиною контенту, що хоститься сторонніми ресурсами (наприклад, іншим сайтом або HTML-електронною поштою) і вказувати на ресурс цього застосунку. Якщо користувач натискає на посилання, оскільки він уже аутентифікований веб-застосунком на сайті, браузер надішле GET-запит до веб-застосунку, супроводжуючи його інформацією для автентифікації (кукі сесії). Це призведе до виконання дії на веб-застосунку, яку користувач не очікував; наприклад, переказу коштів в онлайн-банкінгу.

Використовуючи тег, наприклад, img, як зазначено в пункті 4 вище, навіть не потрібно, щоб користувач переходив за певним посиланням. Припустимо, зловмисник надсилає користувачу електронний лист, який спонукає його відвідати URL, що веде на сторінку, що містить наступний (надто спрощений) HTML.

```html
<html>
    <body>
    ...
    <img src="https://www.company.example/action" width="0" height="0">
    ...
    </body>
</html>
```

Коли браузер відображає цю сторінку, він також спробує завантажити вказане зображення нульових розмірів (отже, невидиме) з `https://www.company.example`. Це призводить до автоматичного надсилання запиту до веб-застосунку, розміщеного на сайті. Не має значення, що URL зображення не веде до правильного зображення, оскільки його наявність все одно викликає виконання вказаної в полі `src` дії запиту. Це відбувається за умови, що завантаження зображень не відключено в браузері. Більшість браузерів не мають відключеного завантаження зображень, оскільки це значно обмежило б функціональність більшості веб-застосунків.

Проблема тут є наслідком:

1. HTML теги на сторінці, що викликають автоматичне виконання HTTP запиту (тег img є одним з таких).
2. Браузер не має способу визначити, що ресурс, на який посилається тег img, не є справжнім зображенням.
3. Завантаження зображення, яке відбувається незалежно від місцезнаходження передбачуваного джерела зображення, тобто форма і саме зображення не обов'язково повинні знаходитися на одному хості або навіть в одному домені.
4. Той факт, що HTML контент, не пов'язаний з веб-застосунком, може посилатися на компоненти застосунку, і браузер автоматично формує дійсний запит до застосунку, дозволяє здійснити таку атаку. Немає способу заборонити таку поведінку, якщо не зробити неможливим для атакуючого взаємодіяти з функціоналом застосунку.

В інтегрованих середовищах пошти та браузера просто відображення електронного листа, що містить посилання на зображення, спричинить виконання запиту до веб-застосунку з супутнім браузерним cookie. Повідомлення електронної пошти може містити, наприклад, посилання на зображення, яке виглядає таким чином:

```html
<img src="https://[attacker]/picture.gif" width="0" height="0">
```

У цьому прикладі, `[attacker]` — це сайт, який контролює атакуючий. Використовуючи механізм редиректу, шкідливий сайт може використати `http://[attacker]/picture.gif`, щоб перенаправити жертву на `http://[thirdparty]/action` і викликати дію.

Cookies — не єдиний приклад, що стосується цієї вразливості. Веб-застосунки, що повністю покладаються на інформацію про сесію, збережену браузером, також вразливі. Це включає застосунки, що залежать лише від механізмів HTTP-аутентифікації, оскільки інформація для аутентифікації зберігається в браузері і надсилається автоматично з кожним запитом. Це не стосується аутентифікації через форми, яка відбувається лише один раз і генерує деяку форму інформації про сесію, зазвичай cookie.

Припустимо, що жертва увійшла в консоль керування файрволом. Для входу користувач має пройти аутентифікацію, і інформація про сесію зберігається в cookie.

Припустимо, що консоль керування файрволом має функцію, яка дозволяє автентифікованому користувачеві видаляти правило, що вказано його числовим ідентифікатором, або всі правила в конфігурації, якщо користувач вказує `*` (реально це небезпечна функція, але для прикладу вона виглядає цікавою). Наступна сторінка показує функцію видалення. Припустимо, що форма — для спрощення — надсилає GET запит. Для видалення правила номер один:

```
https://[target]/fwmgt/delete?rule=1
```

Для видалення всіх правил:

```
https://[target]/fwmgt/delete?rule=*
```

Цей приклад навмисно спрощений, але він показує вивертливість та небезпеку CSRF атак.

!(https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/images/Session_Riding_Firewall_Management.gif)

Рисунок 4.6.5-2: Керування міжмережевим екраном через Session Riding

Використовуючи форму, зображену на малюнку вище, введення значення * і натискання кнопки "Видалити" надішле наступний GET запит:

https://www.company.example/fwmgt/delete?rule=*
Це видалить всі правила міжмережевого екрану.

![](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/images/Session_Riding_Firewall_Management_2.gif)

Рисунок 4.6.5-3: Керування міжмережевим екраном через Session Riding 2

Користувач також міг би досягти тих самих результатів, вручну надіславши URL:

https://[target]/fwmgt/delete?rule=*
Або, слідуючи за посиланням, яке вказує безпосередньо або через редирект на вищезгаданий URL. Або, знову ж таки, зайшовши на HTML-сторінку з вбудованим тегом img, який вказує на той самий URL.

У всіх цих випадках, якщо користувач наразі увійшов до програми керування міжмережевим екраном, запит буде успішним і змінить конфігурацію міжмережевого екрану. Можна уявити атаки, спрямовані на чутливі програми, що здійснюють автоматичні ставки на аукціонах, грошові перекази, замовлення, змінюють конфігурацію критичних програмних компонентів тощо.

Цікаво, що ці вразливості можуть бути використані за межами міжмережевого екрану; тобто достатньо, щоб посилання, яке атакують, було доступне для жертви, а не безпосередньо для атакуючого. Зокрема, це може бути будь-який веб-сервер інтрамережі; наприклад, у сценарії керування міжмережевим екраном, згаданому раніше, який малоймовірно буде відкритий для Інтернету.

Програми, що є самовразливими, тобто програми, які використовуються як атакувальний вектор і ціль (наприклад, веб-поштові програми), ускладнюють ситуацію. Оскільки користувачі увійшли в систему, коли читають свої електронні листи, вразлива програма такого типу може дозволити атакуючим виконувати такі дії, як видалення повідомлень або відправлення повідомлень, які здаються такими, що надійшли від жертви.

**Цілі тестування**
Визначити, чи можливо ініціювати запити від імені користувача, які не були ініційовані самим користувачем.

**Як тестувати**
Аудитувати програму, щоб з'ясувати, чи є її управління сесіями вразливим. Якщо управління сесіями залежить тільки від значень на клієнтській стороні (інформації, доступної браузеру), то програма вразлива. "Значення на клієнтській стороні" відносяться до cookies і HTTP-автентифікаційних облікових даних (Basic Authentication та інші форми HTTP-автентифікації; не автентифікація на основі форм, яка є автентифікацією на рівні програми).

Ресурси, доступні через HTTP GET запити, легко вразливі, хоча POST запити також можуть бути автоматизовані через JavaScript і теж є вразливими; тому використання лише POST не є достатнім для виправлення вразливостей CSRF.

У випадку з POST можна використовувати наступний зразок:

Створіть HTML-сторінку, подібну до наведеного нижче
Розмістіть HTML на шкідливому або сторонньому сайті
Надішліть посилання на сторінку жертві та спонукати її натискати на нього.
```html
<html>
<body onload='document.CSRF.submit()'>

<form action='http://targetWebsite/Authenticate.jsp' method='POST' name='CSRF'>
    <input type='hidden' name='name' value='Hacked'>
    <input type='hidden' name='password' value='Hacked'>
</form>

</body>
</html>
```

У випадку веб-додатків, в яких розробники використовують JSON для комунікації між браузером і сервером, може виникнути проблема через відсутність параметрів запиту у форматі JSON, що є обов'язковим для форм, що самостійно надсилаються. Щоб обійти цей випадок, ми можемо використати форму, що самостійно надсилається з JSON-пейлоадами, що включають приховані входи для експлуатації CSRF. Нам потрібно змінити тип кодування (enctype) на text/plain, щоб переконатися, що пейлоад буде переданий як є. Код експлойту виглядатиме так:

```html
<html>
 <body>
  <script>history.pushState('', '', '/')</script>
   <form action='http://victimsite.com' method='POST' enctype='text/plain'>
     <input type='hidden' name='{"name":"hacked","password":"hacked","padding":"'value='something"}' />
     <input type='submit' value='Submit request' />
   </form>
 </body>
</html>
```

POST запит буде виглядати наступним чином:

```
POST / HTTP/1.1
Host: victimsite.com
Content-Type: text/plain

{"name":"hacked","password":"hacked","padding":"=something"}
```

Коли ці дані надіслено як POST запит, сервер прийме поля name та password і проігнорує поле padding, оскільки воно не потрібне.

**Виправлення**
Див. OWASP CSRF Prevention Cheat Sheet для запобіжних заходів.

**Інструменти**
ZAP  
CSRF Tester  
Pinata-csrf-tool

**Посилання**
Peter W: “Cross-Site Request Forgeries”  
Thomas Schreiber: “Session Riding”  
Oldest known post  
Cross-site Request Forgery FAQ  
A Most-Neglected Fact About Cross Site Request Forgery (CSRF)  
Multi-POST CSRF  
SANS Pen Test Webcast: Complete Application pwnage via Multi POST XSRF

